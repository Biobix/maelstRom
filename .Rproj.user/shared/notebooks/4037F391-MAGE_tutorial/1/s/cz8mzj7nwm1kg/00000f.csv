"0","ParCASE <- vector(mode = ""list"", length=NC)"
"0","for(i in 1:NC){ # Put the splitted input data into a list for parallellisation"
"0","  ParCASE[[i]] <- caseList[(spl[i]+1):(spl[i+1])]"
"0","}"
"0","ParTOT <- vector(mode = ""list"", length=NC)"
"0","for(i in 1:NC){ # Put the splitted input data into a list for parallellisation"
"0","  ParTOT[[i]] <- list(ParCTRL[[i]], ParCASE[[i]])"
"0","}"
"0",""
"0","dAD_analysis <- function(data){"
"0","  "
"0","  controlListP <- data[[1]]"
"0","  caseListP <- data[[2]]"
"0","  positions <- names(controlListP)"
"0","  "
"0","  dAD_res <- data.frame(LocName = names(controlListP), PiFitH0 = 0, PiFitH1 = 0, ThetaH0 = 0,"
"0","    ThetaCTRL_H1 = 0, ThetaCASE_H1 = 0, RhoH0 = 0, RhoCTRL = 0, RhoCASE = 0, LRTpval = 0, "
"0","    NumHetCTRL = 0, NumHetCASE = 0, RobFlagCTRL = """", RobFlagCASE = """", HWECTRL = 0,"
"0","    HWECASE = 0, CovCTRL_mean = 0, CovCASE_mean = 0, CovCTRL_med = 0, CovCASE_med = 0,"
"0","    NumOutCTRL = 0, NumOutCASE = 0, QualityCTRL = ""N"", QualityCASE = ""N"", pr = 0, "
"0","    prv = 0, pv = 0, ThetaHom = 0)"
"0",""
"0","  for (LOC in positions) {"
"0","    "
"0","    CTRL_DF <- data.frame(""ref_count"" = controlListP[[LOC]]$ref_count, "
"0","                       ""var_count"" = controlListP[[LOC]]$var_count, ""isCase"" = 0)"
"0","    CASE_DF <- data.frame(""ref_count"" = caseListP[[LOC]]$ref_count, "
"0","                       ""var_count"" = caseListP[[LOC]]$var_count, ""isCase"" = 1)"
"0","    "
"0","    # Previously, we used EMfit_betabinom_robust() to ROBUSTLY fit our models by removing"
"0","    # outliers via Cook's distance. Now however, we're working with data from two different"
"0","    # sources (control- and case tissue) and have no way of knowing in advance how similar"
"0","    # these are. As such, outlier detections should happen ON BOTH SETS SEPARATELY yet the"
"0","    # two hypotheses we'll be fitting share all or some parameters between the two. "
"0","    # For this, we can use the EMfit_betabinom_robust() function with its ""fitH0"" set to "
"0","    # FALSE, which will not complete the entire eqtl-detection pipeline, but will cut it "
"0","    # short before fitting the unshifted model. By running this function on both our "
"0","    # datasets separately in advance of the dAD-relevant fits, we ensure correct outlier"
"0","    # detection Ã¡nd the use of the same dataset in our upcoming likelihood ratio tests."
"0","  "
"0","    # 1. Detect and extract outliers using EMfit_betabinom_robust()"
"0","    OUTfitCTRL <- MAGE::EMfit_betabinom_robust(data_counts = CTRL_DF, SE = SEmedian, "
"0","                                               inbr = Fmedian, fitH0 = FALSE)"
"0","    OUTfitCASE <- MAGE::EMfit_betabinom_robust(data_counts = CASE_DF, SE = SEmedian,"
"0","                                               inbr = Fmedian, fitH0 = FALSE)"
"0","    OUTfitCTRL_DH <- OUTfitCTRL$data_hash; OUTfitCASE_DH <- OUTfitCASE$data_hash"
"0","    CTRL_DF$Outlier <- OUTfitCTRL_DH$Outlier; CASE_DF$Outlier <- OUTfitCASE_DH$Outlier"
"0","    CurDF <- rbind(CTRL_DF, CASE_DF)"
"0","    # These results are also handy for an estimation of the number of heterozygotes in "
"0","    # controls and tumors AND the number of outliers, both good filter criteria."
"0","    # We can also include a ""RobFlag"" which gives more information about outlier detection "
"0","    # (e.g. none detected, or so unreasonably many that none were removed)"
"0","    dAD_res$NumHetCTRL[dAD_res$LocName == LOC] <- sum(OUTfitCTRL_DH$prv)"
"0","    dAD_res$NumHetCASE[dAD_res$LocName == LOC] <- sum(OUTfitCASE_DH$prv)"
"0","    dAD_res$NumOutCTRL[dAD_res$LocName == LOC] <- sum(CTRL_DF$Outlier)"
"0","    dAD_res$NumOutCASE[dAD_res$LocName == LOC] <- sum(CASE_DF$Outlier)"
"0","    dAD_res$RobFlagCTRL[dAD_res$LocName == LOC] <- OUTfitCTRL$RobFlag"
"0","    dAD_res$RobFlagCASE[dAD_res$LocName == LOC] <- OUTfitCASE$RobFlag"
"0","  "
"0","  "
"0","    # 2. Perform one fit on the entire (non-outlying) data, i.e. all parameters shared,"
"0","    # i.e. assuming no dAD; the null hypothesis in dAD detection."
"0","    # Remark this uses the non-robust fitting function, since outliers were already detected."
"0","    NOdAD_fit <- MAGE::EMfit_betabinom(data_counts = CurDF[CurDF$Outlier == 0,], "
"0","      SE = SEmedian, inbr = Fmedian, fitH0 = FALSE)"
"0","    NOdAD_fit_DF <- NOdAD_fit$data_hash"
"0","    PiH0 <- NOdAD_fit$AB"
"0","    rho_rr <- NOdAD_fit$rho_rr; rho_rv <- NOdAD_fit$rho_rv; rho_vv <- NOdAD_fit$rho_vv"
"0","    ThetaHomH0 <- NOdAD_fit$theta_hom; ThetaHetH0 <- NOdAD_fit$theta_het"
"0","  "
"0","    dAD_res$PiFitH0[dAD_res$LocName == LOC] <- PiH0"
"0","    dAD_res$ThetaH0[dAD_res$LocName == LOC] <- ThetaHetH0"
"0","  "
"0","  "
"0","    # 3. Perform a fit on the (non-outlying) data allowing separate theta_het parameters "
"0","    # for control- and case-data"
"0","    FullFit <- MAGE::EMfit_betabinom_popcomb(data_counts = CurDF[CurDF$Outlier == 0,],"
"0","      SE = SEmedian, inbr = Fmedian, probshift_init = PiH0)"
"0","    ParamVec <- FullFit$ParamVec"
"0","    dAD_res$PiFitH1[dAD_res$LocName == LOC] <- ParamVec[""probshift""]"
"0","    dAD_res$ThetaCTRL_H1[dAD_res$LocName == LOC] <- ParamVec[""theta_het_control""]"
"0","    dAD_res$ThetaCASE_H1[dAD_res$LocName == LOC] <- ParamVec[""theta_het_case""]"
"0","    "
"0","  "
"0","    # 4. Perform the Likelihood Ratio Test for dAD detection"
"0","    # Likelihood of fit with all parameters shared:"
"0","    LikTot <- MAGE::pmf_betabinomMix(CurDF[CurDF$Outlier==0,]$ref_count, "
"0","      CurDF[CurDF$Outlier==0,]$var_count, probshift = PiH0, SEmedian, rho_rr, rho_vv, rho_rv, "
"0","      theta_hom = ThetaHomH0, theta_het = ThetaHetH0)"
"0","    # Likelihood of fit with separate theta_het (calculated in two steps because of the "
"0","    # different theta)"
"0","    LikCTRL <- MAGE::pmf_betabinomMix(CTRL_DF[CTRL_DF$Outlier==0,]$ref_count, "
"0","      CTRL_DF[CTRL_DF$Outlier==0,]$var_count, probshift = ParamVec[""probshift""], SEmedian,"
"0","      ParamVec[""pr""], ParamVec[""pv""], ParamVec[""prv""], theta_hom = ParamVec[""theta_hom""],"
"0","      theta_het = ParamVec[""theta_het_control""])"
"0","    LikCASE <- MAGE::pmf_betabinomMix(CASE_DF[CASE_DF$Outlier==0,]$ref_count, "
"0","      CASE_DF[CASE_DF$Outlier==0,]$var_count, probshift = ParamVec[""probshift""], SEmedian,"
"0","      ParamVec[""pr""], ParamVec[""pv""], ParamVec[""prv""], theta_hom = ParamVec[""theta_hom""], "
"0","      theta_het = ParamVec[""theta_het_case""])"
"0","    lrtstat <- -2 * (sum(log(LikTot)) - sum(log(c(LikCTRL, LikCASE))))"
"0","    LRTpval <- pchisq(lrtstat, df = 1, lower.tail = F)"
"0","    dAD_res$LRTpval[dAD_res$LocName == LOC] <- LRTpval"
"0","  "
"0","  "
"0","    # 5. Fill out the results dataframe"
"0","    dAD_res$QualityCTRL[dAD_res$LocName == LOC] <- # spot bad quality data"
"0","      OUTfitCTRL$quality; dAD_res$QualityCASE[dAD_res$LocName == LOC] <-OUTfitCASE$quality "
"0","    # Test HWE on both the control and tumor data:"
"0","    HWEtest_CTRL <- MAGE::HWE_chisquared(Fmedian = Fmedian, data = OUTfitCTRL_DH)"
"0","    dAD_res$HWECTRL[dAD_res$LocName == LOC] <- HWEtest_CTRL$PVAL"
"0","    HWEtest_CASE <- MAGE::HWE_chisquared(Fmedian = Fmedian, data = OUTfitCASE_DH)"
"0","    dAD_res$HWECASE[dAD_res$LocName == LOC] <- HWEtest_CASE$PVAL"
"0","    # Mean and median coverages:"
"0","    dAD_res$CovCTRL_mean[dAD_res$LocName == LOC] <- "
"0","      mean(CTRL_DF[CTRL_DF$Outlier==0,]$ref_count + CTRL_DF[CTRL_DF$Outlier==0,]$var_count)"
"0","    dAD_res$CovCASE_mean[dAD_res$LocName == LOC] <- "
"0","      mean(CASE_DF[CASE_DF$Outlier==0,]$ref_count + CASE_DF[CASE_DF$Outlier==0,]$var_count)"
"0","    dAD_res$CovCTRL_med[dAD_res$LocName == LOC] <- "
"0","      median(CTRL_DF[CTRL_DF$Outlier==0,]$ref_count + CTRL_DF[CTRL_DF$Outlier==0,]$var_count)"
"0","    dAD_res$CovCASE_med[dAD_res$LocName == LOC] <- "
"0","      median(CASE_DF[CASE_DF$Outlier==0,]$ref_count + CASE_DF[CASE_DF$Outlier==0,]$var_count)"
"0","    dAD_res$pr[dAD_res$LocName == LOC] <- ParamVec[""pr""]"
"0","    dAD_res$prv[dAD_res$LocName == LOC] <- ParamVec[""prv""]"
"0","    dAD_res$pv[dAD_res$LocName == LOC] <- ParamVec[""pv""]"
"0","  "
"0","    dAD_res$ThetaHom[dAD_res$LocName == LOC] <- ParamVec[""theta_hom""]"
"0","  }"
"0",""
"0","  dAD_res$HWECTRL[is.na(dAD_res$HWECTRL)] <- "
"0","  dAD_res$HWECTRL[is.na(dAD_res$HWECTRL)] <- -1"
"0","  "
"0","  dAD_res$RhoH0 <- 1/((1/dAD_res$ThetaH0)+1)"
"0","  dAD_res$RhoCTRL <- 1/((1/dAD_res$ThetaCTRL_H1)+1)"
"0","  dAD_res$RhoCASE <- 1/((1/dAD_res$ThetaCASE_H1)+1)"
"0","    "
"0","  return(dAD_res)"
"0","}"
"0",""
"0","cl <- parallel::makeCluster(getOption(""cl.cores"", NC))"
"0","parallel::clusterExport(cl, c(""Fmedian"", ""SEmedian""))"
"0","dADFinData <- parallel::parLapply(cl, X = ParTOT, fun = dAD_analysis)"
