# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Exact beta-binomial density using a multiprecision library.
#'
#' \code{dBetaBinom_MP} calculates the beta-binomial density while
#' avoiding numerical mistakes (catastrophic cancellations) due to 
#' extreme parameter values. This function is called by \code{dBetaBinom}
#' if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param piX Number. Probability of success; \code{0 >= piX >= 1}
#' @param thetaX Number. Dispersion parameter; \code{0 >= thetaX > +Inf}
#' @param LOG Logical. if TRUE, return log-densities
#' @param NecPres Number. Necessary Precision, i.e. number of bits, for an accurate density calculatation, as determined by the function \code{dBetaBinom}
#' @return A numeric vector of the same length as ms and ns, containing (log-)beta-binomial densities
#' @export
dBetaBinom_MP <- function(ms, ns, piX, thetaX, LOG, NecPres) {
    .Call(`_maelstRom_dBetaBinom_MP`, ms, ns, piX, thetaX, LOG, NecPres)
}

#' Exact gradient of the beta-binomial log-likelihood function for pi using a multiprecision library.
#'
#' \code{grad_pi_MP} calculates the value of the gradient of the beta-binomial log-likelihood function to pi
#' at given data points, while avoiding numerical mistakes (catastrophic cancellations) due to 
#' extreme parameter values. This function is called by \code{grad_pi}
#' if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param piX Number. Probability of success; \code{0 >= piX >= 1}
#' @param thetaX Number. Dispersion parameter; \code{0 >= thetaX > +Inf}
#' @param NecPres Number. Necessary Precision, i.e. number of bits, for an accurate gradient calculatation, as determined by the function \code{grad_pi}
#' @return A numeric vector of the same length as ms and ns, containing the gradient to pi in the give data points
#' @export
grad_pi_MP <- function(ms, ns, piX, thetaX, NecPres) {
    .Call(`_maelstRom_grad_pi_MP`, ms, ns, piX, thetaX, NecPres)
}

#' Exact gradient of the beta-binomial log-likelihood function for theta using a multiprecision library.
#'
#' \code{grad_theta_MP} calculates the value of the gradient of the beta-binomial log-likelihood function to theta
#' at given data points, while avoiding numerical mistakes (catastrophic cancellations) due to 
#' extreme parameter values. This function is called by \code{grad_theta}
#' if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param piX Number. Probability of success; \code{0 >= piX >= 1}
#' @param thetaX Number. Dispersion parameter; \code{0 >= thetaX > +Inf}
#' @param NecPres Number. Necessary Precision, i.e. number of bits, for an accurate gradient calculatation, as determined by the function \code{grad_pi}
#' @return A numeric vector of the same length as ms and ns, containing the gradient to theta in the give data points
#' @export
grad_theta_MP <- function(ms, ns, piX, thetaX, NecPres) {
    .Call(`_maelstRom_grad_theta_MP`, ms, ns, piX, thetaX, NecPres)
}

#' Exact beta-binomial density using sums.
#'
#' \code{dBetaBinom_cpp_old} calculates the beta-binomial density via
#' a number of sums, which is slow for high-value data
#' but fast for low-value data.
#' This function is called by \code{dBetaBinom}
#' if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param pi Number. Probability of success; \code{0 >= pi >= 1}
#' @param theta Number. Dispersion parameter; \code{0 >= theta > +Inf}
#' @param LOG Logical. if TRUE, return log-densities
#' @return A numeric vector of the same length as ms and ns, containing (log-)beta-binomial densities
#' @export
dBetaBinom_cpp_old <- function(ms, ns, pi, theta, LOG) {
    .Call(`_maelstRom_dBetaBinom_cpp_old`, ms, ns, pi, theta, LOG)
}

#' Exact gradient of the beta-binomial log-likelihood function for pi using sums.
#'
#' \code{grad_pi_old} calculates the value of the gradient of the beta-binomial log-likelihood function to pi
#' at given data points via a number of sums, which is slow for high-value data
#' but fast for low-value data.
#' This function is called by \code{grad_pi} if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param pi Number. Probability of success; \code{0 >= pi >= 1}
#' @param theta Number. Dispersion parameter; \code{0 >= theta > +Inf}
#' @return A numeric vector of the same length as ms and ns, containing the gradient to pi in the give data points
#' @export
grad_pi_old <- function(ms, ns, pi, theta) {
    .Call(`_maelstRom_grad_pi_old`, ms, ns, pi, theta)
}

#' Exact gradient of the beta-binomial log-likelihood function for theta using sums.
#'
#' \code{grad_theta_old} calculates the value of the gradient of the beta-binomial log-likelihood function to theta
#' at given data points via a number of sums, which is slow for high-value data
#' but fast for low-value data.
#' This function is called by \code{grad_theta}
#' if necessary, and should not be called outside of this.
#'
#' @param ms Numeric vector. Vector of number of successes
#' @param ns Numeric vector. Vector of number of trials
#' @param pi Number. Probability of success; \code{0 >= pi >= 1}
#' @param theta Number. Dispersion parameter; \code{0 >= theta > +Inf}
#' @return A numeric vector of the same length as ms and ns, containing the gradient to theta in the give data points
#' @export
grad_theta_old <- function(ms, ns, pi, theta) {
    .Call(`_maelstRom_grad_theta_old`, ms, ns, pi, theta)
}

#' DO SOMETHING
#' @export
MyOptTest <- function(parX) {
    .Call(`_maelstRom_MyOptTest`, parX)
}

#' DO SOMETHING
#' @export
dBetaBin_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_dBetaBin_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
dBetaBin_cppi <- function(M, N, PI, THETA, LOG, MemLim, Xtra) {
    .Call(`_maelstRom_dBetaBin_cppi`, M, N, PI, THETA, LOG, MemLim, Xtra)
}

#' @rdname dpqrBetaBinom
#' @export
dBetaBinom <- function(ms, ns, pi, theta, LOG = FALSE, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_dBetaBinom`, ms, ns, pi, theta, LOG, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
GradPi_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_GradPi_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
GradPi_cppi <- function(M, N, PI, THETA, MemLim, Xtra) {
    .Call(`_maelstRom_GradPi_cppi`, M, N, PI, THETA, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
grad_pi <- function(ms, ns, pi, theta, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_grad_pi`, ms, ns, pi, theta, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
GradTheta_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_GradTheta_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
GradTheta_cppi <- function(M, N, PI, THETA, MemLim, Xtra) {
    .Call(`_maelstRom_GradTheta_cppi`, M, N, PI, THETA, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
grad_theta <- function(ms, ns, pi, theta, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_grad_theta`, ms, ns, pi, theta, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
CppCnT_Optim <- function(StartVals, ref_counts, var_counts, isCase, sprv, MemLim = 2048L, Xtra = 7L, step_size = 0.01, tol = 0.1, epsabs = 1e-3) {
    .Call(`_maelstRom_CppCnT_Optim`, StartVals, ref_counts, var_counts, isCase, sprv, MemLim, Xtra, step_size, tol, epsabs)
}

#' DO SOMETHING
#' @export
CppHom_Optim <- function(ThetaHomStart, SE, ref_counts, var_counts, spr, spv, MemLim = 2048L, Xtra = 7L, step_size = 0.01, tol = 0.1, epsabs = 1e-3) {
    .Call(`_maelstRom_CppHom_Optim`, ThetaHomStart, SE, ref_counts, var_counts, spr, spv, MemLim, Xtra, step_size, tol, epsabs)
}

#' DO SOMETHING
#' @export
CppHet_Optim <- function(StartVals, ref_counts, var_counts, sprv, MemLim = 2048L, Xtra = 7L, step_size = 0.01, tol = 0.1, epsabs = 1e-3) {
    .Call(`_maelstRom_CppHet_Optim`, StartVals, ref_counts, var_counts, sprv, MemLim, Xtra, step_size, tol, epsabs)
}

#' DO SOMETHING
#' @export
CppHetH0_Optim <- function(ThetaHetStart, probshift, ref_counts, var_counts, sprv, MemLim = 2048L, Xtra = 7L, step_size = 0.01, tol = 0.1, epsabs = 1e-3) {
    .Call(`_maelstRom_CppHetH0_Optim`, ThetaHetStart, probshift, ref_counts, var_counts, sprv, MemLim, Xtra, step_size, tol, epsabs)
}

#' DO SOMETHING
#' @export
GradPiPi_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_GradPiPi_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
GradPiPi_cppi <- function(M, N, PI, THETA, MemLim, Xtra) {
    .Call(`_maelstRom_GradPiPi_cppi`, M, N, PI, THETA, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
grad_pi_pi <- function(ms, ns, pi, theta, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_grad_pi_pi`, ms, ns, pi, theta, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
GradPiTheta_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_GradPiTheta_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
GradPiTheta_cppi <- function(M, N, PI, THETA, MemLim, Xtra) {
    .Call(`_maelstRom_GradPiTheta_cppi`, M, N, PI, THETA, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
grad_pi_theta <- function(ms, ns, pi, theta, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_grad_pi_theta`, ms, ns, pi, theta, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
MPhelper_GradThetaTheta <- function(M, N, PI, NecPres) {
    .Call(`_maelstRom_MPhelper_GradThetaTheta`, M, N, PI, NecPres)
}

#' DO SOMETHING
#' @export
GradThetaTheta_cppi_MP <- function(M, N, PI, THETA, NecPres) {
    .Call(`_maelstRom_GradThetaTheta_cppi_MP`, M, N, PI, THETA, NecPres)
}

#' DO SOMETHING
#' @export
GradThetaTheta_cppi <- function(M, N, PI, THETA, MemLim, Xtra) {
    .Call(`_maelstRom_GradThetaTheta_cppi`, M, N, PI, THETA, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
grad_theta_theta <- function(ms, ns, pi, theta, MemLim = 2048L, Xtra = 7L) {
    .Call(`_maelstRom_grad_theta_theta`, ms, ns, pi, theta, MemLim, Xtra)
}

#' DO SOMETHING
#' @export
logSums_MaxMethod_CPP <- function(logvec) {
    .Call(`_maelstRom_logSums_MaxMethod_CPP`, logvec)
}

#' DO SOMETHING
#' @export
logSums_MaxMethod_CPP_R <- function(logvec) {
    .Call(`_maelstRom_logSums_MaxMethod_CPP_R`, logvec)
}

#' DO SOMETHING
#' @export
logSums_MaxMethodSigned_CPP <- function(logvec, signvec) {
    .Call(`_maelstRom_logSums_MaxMethodSigned_CPP`, logvec, signvec)
}

#' DO SOMETHING
#' @export
LogTrapezoidalInt_CPP <- function(lower, upper, n, a, b, q, TC, RC, curTR, curRC) {
    .Call(`_maelstRom_LogTrapezoidalInt_CPP`, lower, upper, n, a, b, q, TC, RC, curTR, curRC)
}

#' DO SOMETHING
#' @export
LogNewtonCotes_CPP <- function(lower, upper, a, b, q, TC, RC, curTR, curRC, Wvec) {
    .Call(`_maelstRom_LogNewtonCotes_CPP`, lower, upper, a, b, q, TC, RC, curTR, curRC, Wvec)
}

#' DO SOMETHING
#' @export
LogGaussianQuad_CPP <- function(lower, upper, a, b, q, TC, RC, curTR, curRC, Wvec, Nvec) {
    .Call(`_maelstRom_LogGaussianQuad_CPP`, lower, upper, a, b, q, TC, RC, curTR, curRC, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
LogTanhSinhQuad_CPP <- function(lower, upper, n, a, b, q, TC, RC, curTR, curRC, prec) {
    .Call(`_maelstRom_LogTanhSinhQuad_CPP`, lower, upper, n, a, b, q, TC, RC, curTR, curRC, prec)
}

#' DO SOMETHING
#' @export
TumPurHelpFun_CPP <- function(RCcol, TC, TumReads_oi, a, b, q, SCP_oi, n, NumIntMethod, prec, Wvec, Nvec) {
    .Call(`_maelstRom_TumPurHelpFun_CPP`, RCcol, TC, TumReads_oi, a, b, q, SCP_oi, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPurHelpFun_CPP_R <- function(RCcol, TC, TumReads_oi, a, b, q, SCP_oi, n, NumIntMethod, prec, Wvec, Nvec) {
    .Call(`_maelstRom_TumPurHelpFun_CPP_R`, RCcol, TC, TumReads_oi, a, b, q, SCP_oi, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
qbeta_C <- function(qs, a, b) {
    .Call(`_maelstRom_qbeta_C`, qs, a, b)
}

#' DO SOMETHING
#' @export
qbeta_C3 <- function(qs, a, b) {
    .Call(`_maelstRom_qbeta_C3`, qs, a, b)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2X <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2X`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP3 <- function(q, a, b, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP3`, q, a, b, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP3X <- function(q, a, b, qlim, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP3X`, q, a, b, qlim, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP4 <- function(q, a, b, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP4`, q, a, b, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP_DB1 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP_DB1`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP_DB2 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP_DB2`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP_DB3 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP_DB3`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
BrolDB <- function(TC, TP) {
    .Call(`_maelstRom_BrolDB`, TC, TP)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2_10 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2_10`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2_100 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2_100`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2_1000 <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2_1000`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

#' DO SOMETHING
#' @export
TumPur_LogLik_CPP2Y <- function(optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n = 0L, NumIntMethod = "Gregory", prec = 0.0001, Wvec = 0L, Nvec = 0L) {
    .Call(`_maelstRom_TumPur_LogLik_CPP2Y`, optpars, ref_counts, var_counts, tumpur, weights, SCPthreshold, n, NumIntMethod, prec, Wvec, Nvec)
}

